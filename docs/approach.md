# Understanding Components and an dividing project

We need a flask web service which takes a picture and t,c,k parameters through POST request and responds with the corresponding spline annotated on the image.

So we can divide this project into these parts:

* A web service
* Input validation(Image and tck)
* Spline processing and computing
* Marking image 

All of the above parts come with documents and tests like every project or component.


## 1. Web service

I use a flask template project which I created to organize them in blueprints to avoid complexity when code grows during the project. Blueprints let us organize our project in smaller reusable parts in a similar manner to Django apps. I supposed all services related to spline will go to a blueprint and I chose `\sp` address for its blueprint endpoint.

I have created an `\annotate` endpoint for spline annotation which accepts POST requests with t,c,k and image parameters.

## 2. Input Validation

We will get an image and tck parameters so we have two parts validation

### A. Image validation
For validating requests, I have just checked for image extension but if you upload an image with invalid or corrupted contents it will respond with an error message which has been generated by handling `UnidentifiedImageError` Pillow image library exception. 

Acceptable image extensions can also be configure in `spline_vs\config.py` like below:

```
ALLOWED_IMAGE_EXTENSIONS = {'jpeg', 'jpg', 'png', 'bmp'}
```



### B. TCK validation

t,c and k parameter validation are handled with `ValueError` and `JSONDecodeError`. k parameter is degree of spline so it is just an integer so `ValueError` exception will raise when it is not an integer. Invalid knot points(t) and coefficients(c) also will raise `JSONDecodeError` when they are not in the correct format.

Users may still send invalid parameters, For example 10 coefficients and 1 knot point with degree of 100 which make it impossible to compute a valid spline. For such a situation it will also handle `ValueError` that will raise when using Scipy `interpolate.BSpline`.


## 3. Spline processing and computing

The Scipy `interpolate.BSpline` will return a function that represents computed spline and then we can find `y` values by putting `x` in spline function which means evaluating `y=f(x)=spl(x)` (`yy=spl(xx)` in line 88 of the `spline.py` module).


## 4. Marking Image 

By evaluating spline function we have the `xy` array of `(x,y)` tuples and we can draw lines between them with the `ImageDraw.Draw` handle. I have used the `ellipse` function to draw circles in knot points position to reveal them.


# Documenting

I usually keep in  mind to use the following principles in order to make my code more readable and understandable for other developers or even myself if one day I would come back to add/fix code.

1. Choosing correct variable and functions and module name
2. Adding Inline comments(comments inside code)
3. Put documents inside project folder(ex {project_root}/docs)
4. Alert with right message when handling errors or giving user feedbacks 

Using these rules, documents are accessible for everyone and we can expect developers to read and complete them when it is necessary without switching to another editor or tools(like azure wiki).

Putting documents outside of a project can cause oblivion to read it and in best case it is always out of date because it is hard to switch to other editor or find and synchronize codes and documents together.  


# Testing

For testing projects it is very important to create tests with invalid parameters(especially when we are providing REST APIs for security and giving correct feedback to API users) and try to cover all branches of code.

 Test fixtures in Pytest library provide us a paradigm to initialize and prepare objects that are necessary in many test cases to avoid repeating ourselves. I have created two fixtures, the `client` fixture create a flask's `test_client` object which can be used by other test methods to make REST requests and the `mock_image` fixture creates a black 400x400 mock image encoded in JPEG binary buffer to be used in requests.

 In the following section I described what is purpose of every test function:

 * __`test_spline_annotate_image_bad_extension`__: This method makes a request with a valid image but `txt` extension and expects to get a bad request response for invalid image extensions.

 * __`test_spline_annotate_image`__: This test sends a request with correct 400x400 image and valid tck parameters and expects to get a valid 400x400 image as a response.
  
 * __`test_spline_annotate_image_corrupted_content`__: This will send a text instead of image content to simulate a corrupted image and check if service response with http 400 error code(bad request) and corresponding message.  
  
 * __`test_spline_annotate_without_image`__: Makes a request without attaching an image parameter to test if API users get correct feedback messages when they are not sending image.

 * __`test_spline_annotate_bad_tck`__: This test makes 7 invalid requests with invalid tck parameters. Pytest ***parameterized tests***  let us avoid repeating similar test functions that are only different in parameters. Here we have made a combination of invalid tck parameters to see if it generates the correct error message and http error code.

Above test cases cover 100% of the code which means all functions and branches are covered within tests. But still it may not be complete due to other exceptions that may occur in `Scipy` or `Pillow` libraries;).
